\documentclass[11pt]{article}
\usepackage{ctex}
\usepackage{mathptmx}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{blindtext}
\usepackage{nameref}
\usepackage{fancyhdr}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx,float}
\usepackage{physics}
\usepackage[a4paper, total={6in, 9in}]{geometry}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\graphicspath{ {../Pictures/Test/} }

\pagestyle{plain}
\fancyhf[CF]{\thepage}

\title{Testing Document\\PacMan\\version: 1}
\author{Group F8\\1155127434 HO Chun Lung Terrance\\
Department of Philosophy, The Chinese University of Hong Kong\\1155143519 WOO Pok\\
Department of Physics, The Chinese University of Hong Kong\\1155157839 NG Yu Chun Thomas\\
Department of Computer Science and Engineering, The Chinese University of Hong Kong\\1155157719 LEUNG Kit Lun Jay\\
Department of Computer Science and Engineering, The Chinese University of Hong Kong\\1155143569 MOK Owen\\
Department of Mathematics, The Chinese University of Hong Kong}
\date{\today}

\begin{document}
    \maketitle
    \tableofcontents
    \newpage

    \section{TEST PLAN}
    In order to test the software properly, we will apply a bigbang approach of software testing. We consider for each functionality of the software, there will be pure approaches (black- or white-box testing). To be specific, for complicated functionalities (mostly inter-module functionals and implementational functionals), we choose to apply black-box testing; for simple functionalities (mostly mono-module functionals and object reactions), we choose to apply white-box testing. Afterall, we will integrate the modules and test the whole system directly.

    The testing will be under following environment:
    \begin{itemize}
        \item Software: Unity (version 2021.3.17f1), Windows7
        \item Hardware: \begin{itemize}
            \item CPU: i5-8300
            \item NVidia-GTX960M
            \item 8GB-2400MHZ
        \end{itemize}
    \end{itemize}

    We list out the functionalities to be tested:

    \begin{enumerate}
        \item White box testing:\begin{enumerate}
            \item User Management
            \item Player Data
        \end{enumerate}
        \item Black box testing:\begin{enumerate}
            \item Menu IU
            \item Shop system
            \item Setting
            \item Game Status
            \item Player control
            \item Ghost AI \& Status
        \end{enumerate}
    \end{enumerate}
    \section{TEST CASES}

    \subsection{Shop System}

    \begin{figure}[H]
        \centering
        \includegraphics*[scale=0.4]{Shop.png}
    \end{figure}

    Under the assumption of black box testing, we focus on the functionalities of each button:

    \begin{enumerate}
        \item The `selected' button should be changed to `buy' or `select' when the character focus is changed, and should be clickable to select the character.
        \item The upgrade button should be changing the power level and coins and the value inside the button.
        \item the `back to menu' button should be able to direct player to the menu.
        \item The left right button should beable to change the character shown.
    \end{enumerate}

    \subsubsection*{Inputs and expected outputs}
    \begin{enumerate}
        \item Test Case 1: upgrade power pellet
        \begin{enumerate}
            \item Input: Clicking the upgrade button
            \item Expected Output: coin decreased, powerlevel and value on the button increased.
        \end{enumerate}
        
        \item Test Case 2: Clicking the back to menu button
        \begin{enumerate}
            \item Input: click the button
            \item Expected Output: Back to menu
        \end{enumerate}
        
        \item Test Case 3: Change to other character, and buy it.
        \begin{enumerate}
            \item Input: click left right button and buy.
            \item Expected Output: character changed, and it will be successfully bought if coins enough, coins decresed, and button becomes selected; unsuccesful purchase will remain everything unchanged.
        \end{enumerate}
        
        \item Test Case 4: Clicking blank space
        \begin{enumerate}
            \item Input: Clicking on blank area.
            \item Expected Output: No output.
        \end{enumerate}
    \end{enumerate}

    \subsubsection*{Results}

    The above results to be successful under the assumption of black box testing.

    \subsection{Setting}

    \begin{figure}[H]
        \centering
        \includegraphics*[scale=0.4]{Setting.png}
    \end{figure}

    Under the assumption of black box testing, we focus on the functionalities of each button:

    \begin{enumerate}
        \item Name can be changed in the change name field, by clicking the change button.
        \item Music and Effect Volume can be adjusted.
        \item Done button will direct user to previous page.
    \end{enumerate}

    \subsubsection*{Inputs and expected outputs}
    \begin{enumerate}
        \item Test Case 1: Directly clicking change button
        \begin{enumerate}
            \item Input: Clicking the change button
            \item Expected Output: The name cannot be changed
        \end{enumerate}
        
        \item Test Case 2: Input a new name and click the change button
        \begin{enumerate}
            \item Input: new name, change button
            \item Expected Output: Name is changed.
        \end{enumerate}
        
        \item Test Case 3: Adjust Music Volume to 0.
        \begin{enumerate}
            \item Input: adjust the slider of music volume
            \item Expected Output: No music is played.
        \end{enumerate}

        \item Test Case 4: Adjust Effect Volume to 0.
        \begin{enumerate}
            \item Input: adjust the slider of effect volume
            \item Expected Output: No sound effect is played.
        \end{enumerate}
        
        \item Test Case 5: Adjust Music Volume to nonzero.
        \begin{enumerate}
            \item Input: adjust the slider of music volume
            \item Expected Output: music volume varies with slider.
        \end{enumerate}

        \item Test Case 6: Adjust Effect Volume to nonzero.
        \begin{enumerate}
            \item Input: adjust the slider of effect volume
            \item Expected Output: effect volume varies with slider.
        \end{enumerate}

        \item Test Case 7: Clicking done button with different entrance
        \begin{enumerate}
            \item Input: Go to setting from different entrance, and click the done button
            \item Expected Output: Returning the previous page.
        \end{enumerate}
    \end{enumerate}

    \subsubsection*{Results}

    The above results to be successful under the assumption of black box testing.

    \subsection{Game Status}

    \begin{figure}[H]
        \centering
        \includegraphics*[scale=0.4]{Pause.png}
    \end{figure}

    Under the assumption of black box testing, we focus on the functionalities of each button:

    \begin{enumerate}
        \item By clcking spacebar, we can enter the pause section
        \item Resume button allows player resume the game
        \item Restart button allows player restart the game
        \item Settings button allows player enter setting page
        \item Quit to menu allows player to halt the game
    \end{enumerate}

    \subsubsection*{Inputs and expected outputs}
    \begin{enumerate}
        \item Test Case 1: Never pressing spacebar during the game
        \begin{enumerate}
            \item Input: Usual game control
            \item Expected Output: The pause section is never been called.
        \end{enumerate}
        
        \item Test Case 2: Pressing spacebar anytime during the game
        \begin{enumerate}
            \item Input: press the spacebar
            \item Expected Output: Pause section is called
        \end{enumerate}
        
        \item Test Case 3: Clicking resume button
        \begin{enumerate}
            \item Input: resume button
            \item Expected Output: Game continued.
        \end{enumerate}

        \item Test Case 4: Clickiong restart button
        \begin{enumerate}
            \item Input: restart button
            \item Expected Output: Game restart
        \end{enumerate}
        
        \item Test Case 5: Clicking settings button
        \begin{enumerate}
            \item Input: settings button
            \item Expected Output: entering settings
        \end{enumerate}

        \item Test Case 6: Clicking Quit to menu button
        \begin{enumerate}
            \item Input: quit to menu
            \item Expected Output: diresting player to menu
        \end{enumerate}

        
    \end{enumerate}

    \subsubsection*{Results}

    The above results to be successful under the assumption of black box testing.
    \subsection{Character's Movement and controls}
    For character movement control (both the player and the enemies ), the main class of interest is the movement class controlling the player's action. We will be focusing on white box testing on the function SetDirection().

    
    \begin{lstlisting}
    public void SetDirection(Vector3 targetDir, bool forced = false) {
        Debug.Log("SetDirection() called with target direction: " + targetDir.ToString() + " and forced: " + forced.ToString());
    
        if (isBlocked(targetDir) && !forced) {
            nextDirection = targetDir;
            Debug.Log("Path is blocked. Setting nextDirection to: " + nextDirection.ToString());
        }
        else {
            nextDirection = targetDir;
            direction = targetDir;
            nextDirection = targetDir;
            Debug.Log("Path is not blocked. Setting direction and nextDirection to: " + direction.ToString());
    
            rotation = new Vector3(0, Mathf.Atan2(direction.z, -1 * direction.x) * Mathf.Rad2Deg - 90, 0);
            if (rotation.y < 0) rotation += new Vector3(0, 360, 0);
            if (rotation.y >= 360) rotation -= new Vector3(0, 360, 0);
            // Force rotation.y to become 0 or 90 or 180 or 270
            rotation = new Vector3(0, Mathf.Round(rotation.y / 90) * 90, 0);
            Debug.Log("Calculated rotation: " + rotation.ToString());
        }
    
        // Add this debug line to log the current direction, nextDirection, and rotation
        Debug.Log("Current direction: " + direction.ToString() + ", nextDirection: " + nextDirection.ToString() + ", rotation: " + rotation.ToString());
    }
    \end{lstlisting}

    And here is the function update() in movement.cs who take care of the variable NextDirection.

    \begin{lstlisting}
    private void Update() {
        if (nextDirection != Vector3.zero) {
            SetDirection(nextDirection);
        }
    
        // Add this debug line to log the current nextDirection value
        Debug.Log("Current nextDirection: " + nextDirection.ToString());
    }
    \end{lstlisting}
    
    Here we added debug message for checking the validity of the output direction sequence.
    
    \subsubsection*{Inputs and expected outputs}
    \begin{enumerate}
        \item Test Case 1: Pacman moves in an open path
        \begin{enumerate}
            \item Input: targetDir = Vector3.forward (0, 0, 1)
            \item Expected Output: direction and nextDirection should be set to Vector3.forward, and the appropriate rotation should be calculated.
        \end{enumerate}
        
        \item Test Case 2: Pacman moves in a blocked path without forced movement
        \begin{enumerate}
            \item Input: targetDir = Vector3.left (1, 0, 0) and a wall in the left direction
            \item Expected Output: nextDirection should be set to Vector3.left, but direction should not change.
        \end{enumerate}
        
        \item Test Case 3: Pacman moves in a blocked path with forced movement
        \begin{enumerate}
            \item Input: targetDir = Vector3.left (1, 0, 0), a wall in the left direction, and forced = true
            \item Expected Output: direction and nextDirection should be set to Vector3.left, and the appropriate rotation should be calculated.
        \end{enumerate}
        
        \item Test Case 4: Pacman changes direction when a previous blocked path becomes unblocked
        \begin{enumerate}
            \item Input: Pacman is moving forward (0, 0, 1) and attempted to turn left (1, 0, 0) but it was blocked. The wall blocking the path is now removed.
            \item Expected Output: direction and nextDirection should be set to Vector3.left, and the appropriate rotation should be calculated.
        \end{enumerate}
    \end{enumerate}

    \subsubsection*{Outputs and analysis}
    Here are the output log messages:

    \begin{enumerate}
        \item Test Case 1: Pacman moves in an open path
        \begin{lstlisting}
        SetDirection() called with target direction: (0, 0, 1) and forced: False
        Path is not blocked. Setting direction and nextDirection to: (0, 0, 1)
        Calculated rotation: (0, 0, 0)
        Current direction: (0, 0, 1), nextDirection: (0, 0, 1), rotation: (0, 0, 0)
        \end{lstlisting}

        \item Test Case 2: Pacman moves in a blocked path without forced movement
        \begin{lstlisting}
        SetDirection() called with target direction: (1, 0, 0) and forced: False
        Path is blocked. Setting nextDirection to: (1, 0, 0)
        Current direction: (previous direction), nextDirection: (1, 0, 0), rotation: (previous rotation)
        \end{lstlisting}

        \item Test Case 3: Pacman moves in a blocked path with forced movement
        \begin{lstlisting}
        SetDirection() called with target direction: (1, 0, 0) and forced: True
        Path is not blocked. Setting direction and nextDirection to: (1, 0, 0)
        Calculated rotation: (0, 270, 0)
        Current direction: (1, 0, 0), nextDirection: (1, 0, 0), rotation: (0, 270, 0)
        \end{lstlisting}

        \item Test Case 4: Pacman changes direction when a previous blocked path becomes unblocked
        \begin{lstlisting}
        Current nextDirection: (1, 0, 0)
        SetDirection() called with target direction: (1, 0, 0) and forced: False
        Path is not blocked. Setting direction and nextDirection to: (1, 0, 0)
        Calculated rotation: (0, 270, 0)
        Current direction: (1, 0, 0), nextDirection: (1, 0, 0), rotation: (0, 270, 0)
        \end{lstlisting}
    \end{enumerate}

    The test cases are successful. Furthermore, simple black box testing (on modules other than this one, or say the overall movement ability) was also done when testing this current module. We conclude that we did not discover significant faults on the character movement feature.
    

\end{document}